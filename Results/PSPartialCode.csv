TimeGenerated,EventID,HostApplication
2021-08-25 19:50:29,800,"powershell -nop -ep bypass -c $f=[io.file]::ReadAllText('C:\Windows\Setup\Scripts\HWID_Activation_AIO.cmd') -split ':bat2file\:.*';iex ($f[1]);X 3;X 4; EngineVersion=5.1.19041.1 RunspaceId=ce7efdae-da5b-4182-a2f1-38faedeca585 PipelineId=1 ScriptName= CommandLine=Add-Type -Language CSharp -TypeDefinition @"" Details: CommandInvocation(Add-Type): ""Add-Type"" ParameterBinding(Add-Type): name=""Language""; value=""CSharp"" ParameterBinding(Add-Type): name=""TypeDefinition""; value="" using System.IO; public class BAT85{ public static void Decode(string tmp, string s) { MemoryStream ms=new MemoryStream(); n=0; byte[] b85=new byte[255]; string a85=""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$&()+,-./;=?@[]^_{|}~""; int[] p85={52200625,614125,7225,85,1}; for(byte i=0;i<85;i++){b85[(byte)a85[i]]=i;} bool k=false;int p=0; foreach(char c in s){ switch(c){ case'\0':case'\n':case'\r':case'\b':case'\t':case'\xA0':case' ':case':': k=false;break; default: k=true;break; } if(k){ n+= b85[(byte)c] * p85[p++]; if(p == 5){ ms.Write(n4b(), 0, 4); n=0; p=0; } } } if(p>0){ for(int i=0;i<5-p;i++){ n += 84 * p85[p+i]; } ms.Write(n4b(), 0, p-1); } File.WriteAllBytes(tmp, ms.ToArray()); ms.SetLength(0); } private static byte[] n4b(){ return new byte[4]{(byte)(n>>24),(byte)(n>>16),(byte)(n>>8),(byte)n}; } private static long n=0; }"" "
2021-08-29 01:00:32,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -Command if((Get-ExecutionPolicy ) -ne 'AllSigned') { Set-ExecutionPolicy -Scope Process Bypass }; & 'C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1' EngineVersion=5.1.19041.1151 RunspaceId=ca42ffc1-9476-4d84-bbb5-43badc09c996 PipelineId=1 ScriptName=C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1 CommandLine=Add-Type -AssemblyName System.Windows.Forms Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="AssemblyName"; value="System.Windows.Forms" 
2021-08-29 01:36:01,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -Command if((Get-ExecutionPolicy ) -ne 'AllSigned') { Set-ExecutionPolicy -Scope Process Bypass }; & 'C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1' EngineVersion=5.1.19041.1151 RunspaceId=4313be45-bbfc-47dc-bbfb-b8ba886f4a04 PipelineId=1 ScriptName=C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1 CommandLine=Add-Type -AssemblyName System.Windows.Forms Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="AssemblyName"; value="System.Windows.Forms" 
2021-08-29 01:38:11,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -Command if((Get-ExecutionPolicy ) -ne 'AllSigned') { Set-ExecutionPolicy -Scope Process Bypass }; & 'C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1' EngineVersion=5.1.19041.1151 RunspaceId=0c715806-9277-48db-b9bc-ef499744a5da PipelineId=1 ScriptName=C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1 CommandLine=Add-Type -AssemblyName System.Windows.Forms Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="AssemblyName"; value="System.Windows.Forms" 
2021-08-29 01:40:31,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -Command if((Get-ExecutionPolicy ) -ne 'AllSigned') { Set-ExecutionPolicy -Scope Process Bypass }; & 'C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1' EngineVersion=5.1.19041.1151 RunspaceId=8c4ae416-e2ff-455b-8aa7-fe4e723f3a86 PipelineId=1 ScriptName=C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1 CommandLine=Add-Type -AssemblyName System.Windows.Forms Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="AssemblyName"; value="System.Windows.Forms" 
2021-08-29 01:40:47,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe EngineVersion=5.1.19041.1151 RunspaceId=ce547b84-3cfb-4a83-b5ec-2408f506cb9e PipelineId=129 ScriptName=C:\Users\sayed\Downloads\EventLog-parser-main\EventLogGUI.ps1 CommandLine=Add-Type -AssemblyName System.Windows.Forms Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="AssemblyName"; value="System.Windows.Forms" 
2021-08-29 01:52:02,800,"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe EngineVersion=5.1.19041.1151 RunspaceId=ce547b84-3cfb-4a83-b5ec-2408f506cb9e PipelineId=162 ScriptName=C:\Program Files\WindowsPowerShell\Modules\PowerShellGet\1.0.0.1\PSModule.psm1 CommandLine= Add-Type -ReferencedAssemblies $requiredAssembly -TypeDefinition $source -Language CSharp -ErrorAction SilentlyContinue Details: CommandInvocation(Add-Type): ""Add-Type"" ParameterBinding(Add-Type): name=""ReferencedAssemblies""; value=""System.Management.Automation, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089, ..."" ParameterBinding(Add-Type): name=""TypeDefinition""; value=""using System; using System.Net; using System.Management.Automation; using Microsoft.Win32.SafeHandles; using System.Security.Cryptography; using System.Runtime.InteropServices; using System.Runtime.ConstrainedExecution; using System.Runtime.Versioning; using System.Security; namespace Microsoft.PowerShell.Commands.PowerShellGet { public static class Telemetry { public static void TraceMessageArtifactsNotFound(string[] artifactsNotFound, string operationName) { Microsoft.PowerShell.Telemetry.Internal.TelemetryAPI.TraceMessage(operationName, new { ArtifactsNotFound = artifactsNotFound }); } public static void TraceMessageNonPSGalleryRegistration(string sourceLocationType, string sourceLocationHash, string installationPolicy, string packageManagementProvider, string publishLocationHash, string scriptSourceLocationHash, string scriptPublishLocationHash, string operationName) { Microsoft.PowerShell.Telemetry.Internal.TelemetryAPI.TraceMessage(operationName, new { SourceLocationType = sourceLocationType, SourceLocationHash = sourceLocationHash, InstallationPolicy = installationPolicy, PackageManagementProvider = packageManagementProvider, PublishLocationHash = publishLocationHash, ScriptSourceLocationHash = scriptSourceLocationHash, ScriptPublishLocationHash = scriptPublishLocationHash }); } } /// <summary> /// Used by Ping-Endpoint function to supply webproxy to HttpClient /// We cannot use System.Net.WebProxy because this is not available on CoreClr /// </summary> public class InternalWebProxy : IWebProxy { Uri _proxyUri; ICredentials _credentials; public InternalWebProxy(Uri uri, ICredentials credentials) { Credentials = credentials; _proxyUri = uri; } /// <summary> /// Credentials used by WebProxy /// </summary> public ICredentials Credentials { get { return _credentials; } set { _credentials = value; } } public Uri GetProxy(Uri destination) { return _proxyUri; } public bool IsBypassed(Uri host) { return false; } } [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)] public struct CERT_CHAIN_POLICY_PARA { public CERT_CHAIN_POLICY_PARA(int size) { cbSize = (uint) size; dwFlags = 0; pvExtraPolicyPara = IntPtr.Zero; } public uint cbSize; public uint dwFlags; public IntPtr pvExtraPolicyPara; } [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Unicode)] public struct CERT_CHAIN_POLICY_STATUS { public CERT_CHAIN_POLICY_STATUS(int size) { cbSize = (uint) size; dwError = 0; lChainIndex = IntPtr.Zero; lElementIndex = IntPtr.Zero; pvExtraPolicyStatus = IntPtr.Zero; } public uint cbSize; public uint dwError; public IntPtr lChainIndex; public IntPtr lElementIndex; public IntPtr pvExtraPolicyStatus; } // Internal SafeHandleZeroOrMinusOneIsInvalid class to remove the dependency on .Net Framework 4.6. public abstract class InternalSafeHandleZeroOrMinusOneIsInvalid : SafeHandle { protected InternalSafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) { } public override bool IsInvalid { get { return handle == IntPtr.Zero || handle == new IntPtr(-1); } } } // Internal SafeX509ChainHandle class to remove the dependency on .Net Framework 4.6. [SecurityCritical] public sealed class InternalSafeX509ChainHandle : InternalSafeHandleZeroOrMinusOneIsInvalid { private InternalSafeX509ChainHandle () : base(true) {} internal InternalSafeX509ChainHandle (IntPtr handle) : base (true) { SetHandle(handle); } internal static InternalSafeX509ChainHandle InvalidHandle { get { return new InternalSafeX509ChainHandle(IntPtr.Zero); } } [SecurityCritical] override protected bool ReleaseHandle() { CertFreeCertificateChain(handle); return true; } [DllImport(""Crypt32.dll"", SetLastError=true)] [SuppressUnmanagedCodeSecurity, ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] private static extern void CertFreeCertificateChain(IntPtr handle); } public class Win32Helpers { [DllImport(""Crypt32.dll"", CharSet=CharSet.Auto, SetLastError=true)] public extern static bool CertVerifyCertificateChainPolicy( [In] IntPtr pszPolicyOID, [In] SafeX509ChainHandle pChainContext, [In] ref CERT_CHAIN_POLICY_PARA pPolicyPara, [In,Out] ref CERT_CHAIN_POLICY_STATUS pPolicyStatus); [DllImport(""Crypt32.dll"", CharSet=CharSet.Auto, SetLastError=true)] public static extern SafeX509ChainHandle CertDuplicateCertificateChain( [In] IntPtr pChainContext); [DllImport(""Crypt32.dll"", CharSet=CharSet.Auto, SetLastError=true)] [ResourceExposure(ResourceScope.None)] public static extern SafeX509ChainHandle CertDuplicateCertificateChain( [In] SafeX509ChainHandle pChainContext); public static bool IsMicrosoftCertificate([In] SafeX509ChainHandle pChainContext) { //------------------------------------------------------------------------- // CERT_CHAIN_POLICY_MICROSOFT_ROOT // // Checks if the last element of the first simple chain contains a // Microsoft root public key. If it doesn't contain a Microsoft root // public key, dwError is set to CERT_E_UNTRUSTEDROOT. // // pPolicyPara is optional. However, // MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG can be set in // the dwFlags in pPolicyPara to also check for the Microsoft Test Roots. // // MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG can be set // in the dwFlags in pPolicyPara to check for the Microsoft root for // application signing instead of the Microsoft product root. This flag // explicitly checks for the application root only and cannot be combined // with the test root flag. // // MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG can be set // in the dwFlags in pPolicyPara to always disable the Flight root. // // pvExtraPolicyPara and pvExtraPolicyStatus aren't used and must be set // to NULL. //-------------------------------------------------------------------------- const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = 0x00010000; const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = 0x00020000; //const uint MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = 0x00040000; CERT_CHAIN_POLICY_PARA PolicyPara = new CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS PolicyStatus = new CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_STATUS))); int CERT_CHAIN_POLICY_MICROSOFT_ROOT = 7; PolicyPara.dwFlags = (uint) MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG; bool isMicrosoftRoot = false; if(CertVerifyCertificateChainPolicy(new IntPtr(CERT_CHAIN_POLICY_MICROSOFT_ROOT), pChainContext, ref PolicyPara, ref PolicyStatus)) { isMicrosoftRoot = (PolicyStatus.dwError == 0); } // Also check for the Microsoft root for application signing if the Microsoft product root verification is unsuccessful. if(!isMicrosoftRoot) { // Some Microsoft modules can be signed with Microsoft Application Root instead of Microsoft Product Root, // So we need to use the MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG for the certificate verification. // MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG can not be used // with MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG, // so additional CertVerifyCertificateChainPolicy call is required to verify the given certificate is in Microsoft Application Root. // CERT_CHAIN_POLICY_PARA PolicyPara2 = new CERT_CHAIN_POLICY_PARA(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_PARA))); CERT_CHAIN_POLICY_STATUS PolicyStatus2 = new CERT_CHAIN_POLICY_STATUS(Marshal.SizeOf(typeof(CERT_CHAIN_POLICY_STATUS))); PolicyPara2.dwFlags = (uint) MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG; if(CertVerifyCertificateChainPolicy(new IntPtr(CERT_CHAIN_POLICY_MICROSOFT_ROOT), pChainContext, ref PolicyPara2, ref PolicyStatus2)) { isMicrosoftRoot = (PolicyStatus2.dwError == 0); } } return isMicrosoftRoot; } } } "" ParameterBinding(Add-Type): name=""Language""; value=""CSharp"" ParameterBinding(Add-Type): name=""ErrorAction""; value=""SilentlyContinue"" "
2021-08-29 01:55:54,800,"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe EngineVersion=5.1.19041.1151 RunspaceId=ce547b84-3cfb-4a83-b5ec-2408f506cb9e PipelineId=177 ScriptName=C:\Program Files\WindowsPowerShell\Modules\PSEventViewer\1.0.17\PSEventViewer.psm1 CommandLine=Add-Type -TypeDefinition @"" Details: CommandInvocation(Add-Type): ""Add-Type"" ParameterBinding(Add-Type): name=""TypeDefinition""; value=""using System; namespace PSEventViewer { public enum Keywords : long { AuditFailure = (long) 4503599627370496, AuditSuccess = (long) 9007199254740992, CorrelationHint2 = (long) 18014398509481984, EventLogClassic = (long) 36028797018963968, Sqm = (long) 2251799813685248, WdiDiagnostic = (long) 1125899906842624, WdiContext = (long) 562949953421312, ResponseTime = (long) 281474976710656, None = (long) 0 } }"" "
2021-08-29 01:55:54,800,"C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe EngineVersion=5.1.19041.1151 RunspaceId=ce547b84-3cfb-4a83-b5ec-2408f506cb9e PipelineId=177 ScriptName=C:\Program Files\WindowsPowerShell\Modules\PSEventViewer\1.0.17\PSEventViewer.psm1 CommandLine=Add-Type -TypeDefinition @"" Details: CommandInvocation(Add-Type): ""Add-Type"" ParameterBinding(Add-Type): name=""TypeDefinition""; value=""using System; namespace PSEventViewer { public enum Level { Verbose = 5, Informational = 4, Warning = 3, Error = 2, Critical = 1, LogAlways = 0 } }"" "
2021-08-29 01:55:54,800,C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe EngineVersion=5.1.19041.1151 RunspaceId=ce547b84-3cfb-4a83-b5ec-2408f506cb9e PipelineId=179 ScriptName=C:\Program Files\WindowsPowerShell\Modules\PSWriteExcel\0.1.9\PSWriteExcel.psm1 CommandLine=} else { Add-Type -Path $PSScriptRoot\Lib\Default\EPPlus.Net40.dll } Details: CommandInvocation(Add-Type): "Add-Type" ParameterBinding(Add-Type): name="Path"; value="C:\Program Files\WindowsPowerShell\Modules\PSWriteExcel\0.1.9\Lib\Default\EPPlus.Net40.dll" 
